#include <SPI.h>
#include <Servo.h>

// ------------------ TFT PINS ------------------
#define TFT_CS    10
#define TFT_DC     6
#define TFT_RST    7

// ------------------ ULTRASONIC ----------------
#define TRIG_PIN 9
#define ECHO_PIN 8

// ------------------ SERVO ---------------------
#define SERVO_PIN 5

Servo motor;

// ------------------ GLOBALS -------------------
uint16_t WIDTH  = 128;
uint16_t HEIGHT = 160;

int cx = 64;      // center X
int cy = 140;     // center Y (bottom area)

int prevX = -1;
int prevY = -1;

// ------------------- COLORS -------------------
#define BLACK   0x0000
#define RED     0xF800
#define GREEN   0x07E0
#define BLUE    0x001F
#define WHITE   0xFFFF
#define YELLOW  0xFFE0

// ------------------------------------------------
// LOW-LEVEL WRITE FUNCTIONS
// ------------------------------------------------
void cmd(uint8_t c) {
  digitalWrite(TFT_DC, LOW);
  digitalWrite(TFT_CS, LOW);
  SPI.transfer(c);
  digitalWrite(TFT_CS, HIGH);
}

void data8(uint8_t d) {
  digitalWrite(TFT_DC, HIGH);
  digitalWrite(TFT_CS, LOW);
  SPI.transfer(d);
  digitalWrite(TFT_CS, HIGH);
}

void data16(uint16_t d) {
  data8(d >> 8);
  data8(d & 0xFF);
}

// ------------------------------------------------
// SET ADDRESS WINDOW
// ------------------------------------------------
void setWindow(int x0, int y0, int x1, int y1) {
  cmd(0x2A);
  data16(x0);
  data16(x1);

  cmd(0x2B);
  data16(y0);
  data16(y1);

  cmd(0x2C);
}

// ------------------------------------------------
// FILL SCREEN
// ------------------------------------------------
void fillScreen(uint16_t color) {
  setWindow(0, 0, WIDTH - 1, HEIGHT - 1);
  digitalWrite(TFT_DC, HIGH);
  digitalWrite(TFT_CS, LOW);

  for (uint32_t i = 0; i < WIDTH * HEIGHT; i++) {
    SPI.transfer(color >> 8);
    SPI.transfer(color & 0xFF);
  }

  digitalWrite(TFT_CS, HIGH);
}

// ------------------------------------------------
// DRAW PIXEL
// ------------------------------------------------
void drawPixel(int x, int y, uint16_t color) {
  if (x < 0 || x >= WIDTH || y < 0 || y >= HEIGHT) return;
  setWindow(x, y, x, y);
  data16(color);
}

// ------------------------------------------------
// DRAW LINE
// ------------------------------------------------
void drawLine(int x0, int y0, int x1, int y1, uint16_t color) {
  int dx = abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
  int dy = -abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
  int err = dx + dy, e2;

  for (;;) {
    drawPixel(x0, y0, color);
    if (x0 == x1 && y0 == y1) break;
    e2 = 2 * err;
    if (e2 > dy) { err += dy; x0 += sx; }
    if (e2 < dx) { err += dx; y0 += sy; }
  }
}

// ------------------------------------------------
// DRAW CIRCLE
// ------------------------------------------------
void drawCircle(int x0, int y0, int r, uint16_t color) {
  int x = -r, y = 0, err = 2 - 2 * r;

  do {
    drawPixel(x0 - x, y0 + y, color);
    drawPixel(x0 - y, y0 - x, color);
    drawPixel(x0 + x, y0 - y, color);
    drawPixel(x0 + y, y0 + x, color);

    r = err;
    if (r <= y) err += ++y * 2 + 1;
    if (r > x || err > y) err += ++x * 2 + 1;
  } while (x < 0);
}

// ------------------------------------------------
// TFT INIT FOR YOUR CHINESE ST7735S/ILI9163
// ------------------------------------------------
void initTFT() {
  pinMode(TFT_CS,  OUTPUT);
  pinMode(TFT_DC,  OUTPUT);
  pinMode(TFT_RST, OUTPUT);

  SPI.begin();
  SPI.setClockDivider(SPI_CLOCK_DIV2);

  digitalWrite(TFT_RST, LOW);
  delay(100);
  digitalWrite(TFT_RST, HIGH);
  delay(100);

  cmd(0x01); delay(150);
  cmd(0x11); delay(150);

  cmd(0x3A);
  data8(0x05);

  cmd(0x29); delay(50);

  fillScreen(BLACK);
}

// ------------------------------------------------
// ULTRASONIC
// ------------------------------------------------
int getDistance() {
  digitalWrite(TRIG_PIN, LOW);
  delayMicroseconds(2);

  digitalWrite(TRIG_PIN, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIG_PIN, LOW);

  long duration = pulseIn(ECHO_PIN, HIGH);
  int d = duration * 0.034 / 2;
  if (d > 60) d = 60;
  return d;
}

// ------------------------------------------------
// COORDINATION CONVERSION
// ------------------------------------------------
int getX(int angle, int dist) { return cx + dist * cos(angle * 0.01745); }
int getY(int angle, int dist) { return cy - dist * sin(angle * 0.01745); }

// ------------------------------------------------
// RADAR FRAME
// ------------------------------------------------
void radarFrame() {
  drawCircle(cx, cy, 60, GREEN);
  drawCircle(cx, cy, 45, GREEN);
  drawCircle(cx, cy, 30, GREEN);
  drawCircle(cx, cy, 15, GREEN);

  for (int a = 0; a <= 180; a += 30) {
    drawLine(cx, cy, getX(a, 60), getY(a, 60), GREEN);
  }
}

// ------------------------------------------------
// DRAW INFO TEXT (JUST SIMPLE BLOCKS)
// ------------------------------------------------
void drawInfo(int angle, int dist, int temp) {
  for (int x = 0; x < 128; x++)
    for (int y = 0; y < 15; y++)
      drawPixel(x, y, BLACK);

  // simple digital text-like blocks
  // A: angle D: distance T: temp B: battery

  // (Very simple since no font library)
  drawPixel(5, 5, GREEN);     // indicator dot
}

// ------------------------------------------------
// RADAR SWEEP
// ------------------------------------------------
void radarSweep(int angle) {
  int d = getDistance();
  int px = getX(angle, 60);
  int py = getY(angle, 60);

  if (prevX != -1)
    drawLine(cx, cy, prevX, prevY, BLACK);

  drawLine(cx, cy, px, py, GREEN);

  int objX = getX(angle, d);
  int objY = getY(angle, d);
  drawCircle(objX, objY, 3, RED);

  prevX = px;
  prevY = py;
}

// ------------------------------------------------
// SETUP
// ------------------------------------------------
void setup() {
  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);

  motor.attach(SERVO_PIN);

  initTFT();
  radarFrame();
}

// ------------------------------------------------
// MAIN LOOP
// ------------------------------------------------
void loop() {
  for (int angle = 0; angle <= 180; angle++) {
    motor.write(angle);
    radarSweep(angle);
  }

  for (int angle = 180; angle >= 0; angle--) {
    motor.write(angle);
    radarSweep(angle);
  }
}
